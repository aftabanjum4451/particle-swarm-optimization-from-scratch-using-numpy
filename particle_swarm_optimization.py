# -*- coding: utf-8 -*-
"""Particle Swarm Optimization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P5DKeILbumPGm4B0zLzWZPlWt_wq3t0j

# Particle Swarm Optimization (PSO)

Partials swarm optimization (PSO) is a global numerical algorithm inspired by birds foraging. In PSO the particle migrates towards the direction of a combination of their former velocity personal best and global
best and update its position. In this work, the particles are the weight vectors, and their values are randomly created. For the evaluation of these particles, they are inserted into the neural network and calculate their fitness values. PSO has shown robustness and efficiency in finding global optima.
"""

import math
import numpy as np
import sys 
from numpy import random

def fitness_function(position):
    fitnes_value=position[0]**2 + position[1]**2 + 1
    return fitnes_value,position

class Particle:
    def __init__(self,x0):
        self.position_i=[]          # particle position
        self.velocity_i=[]          # particle velocity
        self.pos_best_i=[]          # best position individual
        self.err_best_i=-1          # best error individual
        self.string_afterrnn=1
        self.array_st_calfitness=[]
        self.best_string=[]
        self.err_i=-1               # error individual

        for i in range(0,num_dimensions):
            self.velocity_i.append(random.uniform(-1,1))
            self.position_i.append(x0[i])
        #print("print len(self.position_i)",self.position_i)

    def evaluate(self,fitness_function):
        self.err_i=fitness_function(self.position_i)
        # check to see if the current position is an individual best
        if self.err_i[0] < self.err_best_i or self.err_best_i==-1:
            self.pos_best_i=self.position_i
            self.err_best_i=self.err_i[0]
            self.best_string=self.err_i[1]
        print('Local best fitness value',self.err_best_i)
        return self.err_best_i,self.best_string

    # update new particle velocity
    def update_velocity(self,pos_best_g):
        w=0.95       # constant inertia weight (how much to weigh the previous velocity)
        c1=1.8        # cognative constant
        c2=1.8       # social constant

        for i in range(0,num_dimensions):
            r1=random.uniform(0, 1)
            r2=random.uniform(0, 1)
            #r1=random.random()
            #r2=random.random()

            vel_cognitive=c1*r1*(self.pos_best_i[i]-self.position_i[i])
            vel_social=c2*r2*(pos_best_g[i]-self.position_i[i])
            self.velocity_i[i]=w*self.velocity_i[i]+vel_cognitive+vel_social

    # update the particle position based off new velocity updates
    def update_position(self,bounds):
        for i in range(0,num_dimensions):
            self.position_i[i]=self.position_i[i]+self.velocity_i[i]

            # if want to adjust maximum position if necessary
            # if self.position_i[i]>bounds[i][1]:
            #     self.position_i[i]=bounds[i][1]

            # if want to adjust minimum position if neseccary
            # if self.position_i[i] < bounds[i][0]:
            #     self.position_i[i]=bounds[i][0]

class PSO():
    def __init__(self,fitness,x0,bounds,num_particles,maxiter):
        global num_dimensions
        num_dimensions=len(x0)
        err_best_g=-1                   # best error for group
        pos_best_g=[]                   # best position for group
        best_stringnow=[]
        # establish the swarm
        swarm=[]
        for i in range(0,num_particles):
            swarm.append(Particle(x0))

        # begin optimization loop
        i=0
        while i < maxiter:
            print("number of generation ",i)
            print('gloabl G best',err_best_g)
            # cycle through particles in swarm and evaluate fitness
            for j in range(0,num_particles):
                swarm[j].evaluate(fitness_function)

                # determine if current particle is the best (globally)
                if swarm[j].err_i[0] < err_best_g or err_best_g == -1:
                    pos_best_g=list(swarm[j].position_i)
                    err_best_g=float(swarm[j].err_i[0])
                    best_stringnow=list(swarm[j].err_i[1])

            # cycle through swarm and update velocities and position
            for j in range(0,num_particles):
                swarm[j].update_velocity(pos_best_g)
                swarm[j].update_position(bounds)
            i+=1

      
        print(" The best fitness value: ", err_best_g,"The best solution partical: ", best_stringnow )

if __name__ == "__PSO__":
    main()
n_iterations = int(input("Inform the number of iterations: "))
n_particles = int(input("Inform the number of particles: "))
pop1=[]
pop1=random.randint(-1,10,size=2)
initial=pop1     # initial starting location [x1,x2...]
bounds=[(-1,10),(-1,10)]  # input bounds [(x1_min,x1_max),(x2_min,x2_max)...], if we want to adujst the max and min range value of postion  of partical
PSO(fitness_function ,initial,bounds,num_particles=n_particles,maxiter=n_iterations)

1